### 结构体字面量
使用`Name:`语法可以仅列出部分字段(字段名的顺序无关) 特殊的前缀`&`返回一个指向结构体的指针
~~~ go
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
	v2 = Vertex{X: 1}  // Y:0 被隐式地赋予零值
	v3 = Vertex{}      // X:0 Y:0
	p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
~~~

### 数组
`var a [10]int;`

### 切片
为数组元素提供了动态视角
`[] T`表示一个元素类型为T的切片 `a[low: high]` 为半闭半开空间包括第一个不包括最后一个
当改变其元素时，改变的是其底层的元素

当构建切片的时候，如果空格内不填写东西的话，那么会先构建一个数组，然后再构建一个切片

进行切片时，可以利用默认行为忽略上下界。下界默认值为0，上界是该切片的长度例如`a[0:10],[:]{0:}`等与一个长度为10的数组等价。

长度用`lens(s)`,容量用`caps(s)`来表示
切片的零值是nil 其切片的长度和容量为0且没有底层数组

切片也可以用内置函数make来创建，
make函数会分配一个元素为0值的数组并返回一个引用它的切片
~~~ go
a := make([]int, 5);
~~~
如果需要指定容量，需向`make`传入第三个参数：
~~~ go
b := make([]int, 0, 5) //len(b) = 0, cap(b) = 5
b = b[:cap(b)] //len=5 cap=5
b = b[1:] //len/cap = 4
~~~

切片可以包含任何类型，甚至其他切片
slices-of-slices
切片追加元素 `append`
`func append(s []T, vs, ...T) []T`
s是一个元素类型为T的切片，其余类型为T的值将会追加到该切片的末尾
`append`的结果是一个包含原切片所有元素加上新添加元素的切片
当s的底层数组太小，不足以容纳所有时，他就会分配一个更大的数组，返回的切片会指向这个新分配的数组

append.go
for 循环的range形式可遍历切片或映射。每次迭代都会返回两个值，第一个值为元素下标，第二个值为下标所对应元素的一份副本。

range.go

也可以将下标或值赋予_来忽略

range-continued.go